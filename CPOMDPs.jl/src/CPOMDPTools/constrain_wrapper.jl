abstract type ConstrainMDPWrapper{M,S,A} <: CMDP{S,A} where {M<:MDP} end
POMDPs.discount(m::ConstrainMDPWrapper) = POMDPs.discount(m.mdp)
POMDPs.transition(m::ConstrainMDPWrapper, s, a) = POMDPs.transition(m.mdp, s, a)
POMDPs.reward(m::ConstrainMDPWrapper, s, a) = POMDPs.reward(m.mdp, s, a) 
POMDPs.reward(m::ConstrainMDPWrapper, s, a, sp) = POMDPs.reward(m.mdp, s, a, sp) 
POMDPs.isterminal(m::ConstrainMDPWrapper, s) = POMDPs.isterminal(m.mdp, s) 
POMDPs.initialstate(m::ConstrainMDPWrapper) = POMDPs.initialstate(m.mdp) 
POMDPs.stateindex(problem::ConstrainMDPWrapper, s) = POMDPs.stateindex(problem.mdp, s) 
POMDPs.actionindex(problem::ConstrainMDPWrapper, a) = POMDPs.actionindex(problem.mdp, a) 
POMDPs.convert_s(a, b, problem::ConstrainMDPWrapper) = POMDPs.convert_s(a, b, problem.mdp) 
POMDPs.convert_a(a, b, problem::ConstrainMDPWrapper) = POMDPs.convert_a(a, b, problem.mdp) 
POMDPs.convert_o(a, b, problem::ConstrainMDPWrapper) = POMDPs.convert_o(a, b, problem.mdp) 
#simulate(sim::Simulator, m::ConstrainMDPWrapper, p::Policy, s0=rand(initialstate(m)))
POMDPs.states(problem::ConstrainMDPWrapper) = POMDPs.states(problem.mdp) 
POMDPs.actions(m::ConstrainMDPWrapper) = POMDPs.actions(m.mdp) 
POMDPs.actions(m::ConstrainMDPWrapper, s) = POMDPs.actions(m.mdp, s) 
POMDPs.statetype(p::ConstrainMDPWrapper) = POMDPs.statetype(p.mdp) 
POMDPs.actiontype(p::ConstrainMDPWrapper) = POMDPs.actiontype(p.mdp) 
function POMDPs.gen(m::ConstrainMDPWrapper, s, a, args...)
    nt = POMDPs.gen(m.mdp, s, a, args...)
    if :sp in keys(nt)
        return merge(nt, (;c=costs(m,s,a,nt[:sp])))
    end
    return nt
end

abstract type ConstrainPOMDPWrapper{P,S,A,O} <: CPOMDP{S,A,O} where {P<:POMDP} end
POMDPs.discount(m::ConstrainPOMDPWrapper) = POMDPs.discount(m.pomdp)
POMDPs.transition(m::ConstrainPOMDPWrapper, state, action) = POMDPs.transition(m.pomdp, state, action)
POMDPs.observation(m::ConstrainPOMDPWrapper, statep) = POMDPs.observation(m.pomdp, statep)
POMDPs.observation(m::ConstrainPOMDPWrapper, action, statep) = POMDPs.observation(m.pomdp, action, statep)
POMDPs.observation(m::ConstrainPOMDPWrapper, state, action, statep) = POMDPs.observation(m.pomdp, state, action, statep)
POMDPs.reward(m::ConstrainPOMDPWrapper, s, a) = POMDPs.reward(m.pomdp, s, a)
POMDPs.reward(m::ConstrainPOMDPWrapper, s, a, sp) = POMDPs.reward(m.pomdp, s, a, sp)
POMDPs.reward(m::ConstrainPOMDPWrapper, s, a, sp, o) = POMDPs.reward(m.pomdp, s, a, sp, o)
POMDPs.isterminal(m::ConstrainPOMDPWrapper, s) = POMDPs.isterminal(m.pomdp, s)
POMDPs.initialstate(m::ConstrainPOMDPWrapper) = POMDPs.initialstate(m.pomdp)
POMDPs.initialobs(m::ConstrainPOMDPWrapper, s) = POMDPs.initialobs(m.pomdp, s)
POMDPs.stateindex(problem::ConstrainPOMDPWrapper, s) = POMDPs.stateindex(problem.pomdp, s)
POMDPs.actionindex(problem::ConstrainPOMDPWrapper, a) = POMDPs.actionindex(problem.pomdp, a)
POMDPs.obsindex(problem::ConstrainPOMDPWrapper, o) = POMDPs.obsindex(problem.pomdp, o)
POMDPs.convert_s(a, b, problem::ConstrainPOMDPWrapper) = POMDPs.convert_s(a, b, problem.pomdp)
POMDPs.convert_a(a, b, problem::ConstrainPOMDPWrapper) = POMDPs.convert_a(a, b, problem.pomdp)
POMDPs.convert_o(a, b, problem::ConstrainPOMDPWrapper) = POMDPs.convert_o(a, b, problem.pomdp) 
# simulate(sim::Simulator, m::ConstrainPOMDPWrapper, p::Policy, u::Updater=updater(p), b0=initialstate(m), s0=rand(b0))
POMDPs.states(problem::ConstrainPOMDPWrapper) = POMDPs.states(problem.pomdp)
POMDPs.actions(m::ConstrainPOMDPWrapper) = POMDPs.actions(m.pomdp)
POMDPs.actions(m::ConstrainPOMDPWrapper, s) = POMDPs.actions(m.pomdp, s)
POMDPs.observations(problem::ConstrainPOMDPWrapper) = POMDPs.observations(problem.pomdp)
POMDPs.observations(problem::ConstrainPOMDPWrapper, s) = POMDPs.observations(problem.pomdp, s) 
POMDPs.statetype(p::ConstrainPOMDPWrapper) = POMDPs.statetype(p.pomdp)
POMDPs.actiontype(p::ConstrainPOMDPWrapper) = POMDPs.actiontype(p.pomdp)
POMDPs.obstype(p::ConstrainPOMDPWrapper) = POMDPs.obstype(p.pomdp)
function POMDPs.gen(m::ConstrainPOMDPWrapper, s, a, args...)
    nt = POMDPs.gen(m.pomdp, s, a, args...)
    if :sp in keys(nt)
        return merge(nt, (;c=costs(m,s,a,nt[:sp], nt[:o])))
    end
    return nt
end